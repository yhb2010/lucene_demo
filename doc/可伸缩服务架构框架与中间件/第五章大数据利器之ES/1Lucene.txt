分段存储：
	段不变性的优点：
	1、不需要锁。因为数据不会更新，所以不用考虑多线程下的读写不一致情况。
	2、可以常驻内存。段在被加载到内存后，由于具有不变性，所以只要内存的空间足够大，就可以长时间驻存，大部分查询请求会直接访问内存，而不需要访问磁盘，
	使得查询的性能有很大的提升。
	3、缓存友好。在段的声明周期内始终有效，不需要在每次数据更新时被重建。
	4、增量创建。分段可以做到增量创建索引，可以轻量级的对数据进行更新，由于每次创建的成本很低，所以可以频繁的更新数据，使系统接近实时更新。

	段不变性的缺点：
	1、当对数据进行删除时，旧数据不会被马上删除，而是在.del文件中被标记为删除。而旧数据只能等到段更新时才能真正被移除，这样会有大量的空间浪费。
	2、更新。更新数据由删除和新增这两个动作组成，若有一条数据频繁更新，则会有大量的空间浪费。
	3、由于索引具有不变性，所以每次新增数据时，都需要新增一个段来存储数据。当段的数量太多时，对服务器的资源（如文件句柄）的消耗会非常大，查询的性能也会
	受到影响。
	4、在查询后需要对已经删除的旧数据进行过滤，这增加了查询的负担。

为了提升写性能，Lucene并没有每新增一条数据就增加一个段，而是采用延迟写的策略，每当有新增的数据时，就将其先写入内存中，然后批量写入磁盘，若有一个段被写到
硬盘，就会生成一个提交点，提交点就是一个用来记录所有提交后的段信息的文件。一个段一旦拥有了提交点，就说明这个段只有读的权限，失去了写的权限；相反，当段在
内存中时，就只有写数据的权限，而不具备读数据的权限，所以也就不能被检索了。从严格意义上说，Lucene或ES并不能被称为实时的搜索引擎，只能被称为准实时的搜索引
擎。

写流程如下：
	1、新数据被写入时，并没有被直接写入到硬盘中，而是被暂时写到内存中，Lucene默认是一秒钟，或者当内存中的数据量达到一定阶段时，再批量提交到磁盘中。当然，
	默认的时间和数据量的大小是可以通过参数控制的。通过延迟写的策略，可以减少数据往磁盘上写的次数，从而提升整体的写入性能。
	2、在达到触发条件以后，会将内存中缓存的数据一次性写入磁盘中，并生成提交点。
	3、清空内存，等待新的数据写入。
	数据先被内存缓存，如果这时出现断电等不可控的情况，会丢失数据，因此ES添加了事务日志，来保证数据的安全。

段合并：
	根据段的大小先将段进行合并，再将属于同一组的段进行合并，但是由于对超级大的段的合并需要消耗更多的资源，所以Lucene会在段的大小达到一定规模，或者段里面
	的数据量达到一定条数后，不会再进行合并。所以Lucene的段合并主要集中在中小段的合并上，这样既可以避免对大段进行合并时消耗过多的服务器资源，也可以很好的
	控制索引中段的数量。

	段合并的主要参数：
	1、mergeFactor：每次合并时参与合并的段的最少数量，当同一组的段的数量达到此值时开始合并，如果小于此值则不合并，这样做可以减少段合并的频率，默认值10
	2、SegmentSize：段的实际大小，单位为字节。
	3、minMergeSize：小于这个值的段会被分到一组，这样可以加速小片段的合并。
	4、maxMergeSize：若一个段的文本数量大于此值，就不再参与合并，因为大段合并会消耗更多的资源
	段合并相关的动作主要有以下两个
	1、对索引中的段进行分组，把大小相近的段分到一组，主要由LogMergePolicy来处理。
	2、将属于同一个分组的段合并成一个更大的段。
